{"version":3,"sources":["../src/components/tabs/color-utils.ts","../src/components/tabs/web.ts","../src/index.ts","../src/components/tabs/index.ts"],"sourcesContent":["/**\n * Color validation utilities for TabsBar configuration\n */\n\n/**\n * Validates if a string is a valid hex color code\n * @param color - The color string to validate\n * @returns true if valid hex color, false otherwise\n */\nexport function isValidHexColor(color: string): boolean {\n  const hexRegex = /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;\n  return hexRegex.test(color);\n}\n\n/**\n * Validates if a string is a valid RGBA color code\n * @param color - The color string to validate\n * @returns true if valid RGBA color, false otherwise\n */\nexport function isValidRgbaColor(color: string): boolean {\n  const rgbaRegex = /^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i;\n  \n  const match = color.match(rgbaRegex);\n  if (!match) return false;\n  \n  const [, r, g, b, a] = match;\n  const red = parseFloat(r);\n  const green = parseFloat(g);\n  const blue = parseFloat(b);\n  const alpha = a ? parseFloat(a) : 1;\n  \n  return (\n    red >= 0 && red <= 255 &&\n    green >= 0 && green <= 255 &&\n    blue >= 0 && blue <= 255 &&\n    alpha >= 0 && alpha <= 1\n  );\n}\n\n/**\n * Validates if a string is a valid color (hex or RGBA)\n * @param color - The color string to validate\n * @returns true if valid color format, false otherwise\n */\nexport function isValidColor(color: string): boolean {\n  if (!color || typeof color !== 'string') return false;\n  return isValidHexColor(color) || isValidRgbaColor(color);\n}\n\n/**\n * Converts hex color to RGBA format\n * @param hex - Hex color string (e.g., \"#FF5733\" or \"#F57\")\n * @param alpha - Optional alpha value (0-1), defaults to 1\n * @returns RGBA color string or null if invalid hex\n */\nexport function hexToRgba(hex: string, alpha: number = 1): string | null {\n  if (!isValidHexColor(hex)) return null;\n  \n  // Remove # if present\n  hex = hex.replace('#', '');\n  \n  // Handle 3-digit hex\n  if (hex.length === 3) {\n    hex = hex.split('').map(char => char + char).join('');\n  }\n  \n  // Handle 8-digit hex (with alpha)\n  if (hex.length === 8) {\n    const alphaHex = hex.slice(6, 8);\n    alpha = parseInt(alphaHex, 16) / 255;\n    hex = hex.slice(0, 6);\n  }\n  \n  const r = parseInt(hex.slice(0, 2), 16);\n  const g = parseInt(hex.slice(2, 4), 16);\n  const b = parseInt(hex.slice(4, 6), 16);\n  \n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\n/**\n * Normalizes a color string to a consistent format for native processing\n * @param color - Color string in hex or RGBA format\n * @returns Normalized color object with r, g, b, a values (0-1 range) or null if invalid\n */\nexport function normalizeColor(color: string): { r: number; g: number; b: number; a: number } | null {\n  if (!color || typeof color !== 'string') return null;\n  \n  if (isValidHexColor(color)) {\n    const rgba = hexToRgba(color);\n    if (!rgba) return null;\n    color = rgba;\n  }\n  \n  if (isValidRgbaColor(color)) {\n    const match = color.match(/^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i);\n    if (!match) return null;\n    \n    const [, r, g, b, a] = match;\n    return {\n      r: parseFloat(r) / 255,\n      g: parseFloat(g) / 255,\n      b: parseFloat(b) / 255,\n      a: a ? parseFloat(a) : 1\n    };\n  }\n  \n  return null;\n}","import { WebPlugin } from \"@capacitor/core\";\nimport type {\n  TabsBarPlugin,\n  TabsBarConfigureOptions,\n  SelectOptions,\n  SetBadgeOptions,\n  SafeAreaInsets,\n  TabItem,\n  ImageIcon,\n  ImageLoadingState\n} from \"./definitions\";\nimport { isValidColor } from \"./color-utils\";\n\n/** Image cache for remote URLs */\ninterface CachedImage {\n  url: string;\n  blob: Blob;\n  timestamp: number;\n  objectUrl: string;\n}\n\n/** Image validation utilities */\nclass ImageValidator {\n  private static readonly SUPPORTED_FORMATS = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'];\n  private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n  \n  static isValidImageFormat(contentType: string): boolean {\n    return this.SUPPORTED_FORMATS.includes(contentType.toLowerCase());\n  }\n  \n  static isValidBase64DataUri(dataUri: string): boolean {\n    const base64Pattern = /^data:image\\/(png|jpeg|jpg|svg\\+xml|webp);base64,/i;\n    return base64Pattern.test(dataUri);\n  }\n  \n  static isValidHttpUrl(url: string): boolean {\n    try {\n      const urlObj = new URL(url);\n      return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';\n    } catch {\n      return false;\n    }\n  }\n  \n  static validateImageSize(blob: Blob): boolean {\n    return blob.size <= this.MAX_FILE_SIZE;\n  }\n}\n\n/** Image loading and caching manager */\nclass ImageManager {\n  private static cache = new Map<string, CachedImage>();\n  private static readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n  private static loadingPromises = new Map<string, Promise<string>>();\n  \n  static async loadImage(imageIcon: ImageIcon): Promise<string> {\n    const { image } = imageIcon;\n    \n    // Handle base64 data URIs\n    if (ImageValidator.isValidBase64DataUri(image)) {\n      return image;\n    }\n    \n    // Handle remote URLs\n    if (ImageValidator.isValidHttpUrl(image)) {\n      return this.loadRemoteImage(image);\n    }\n    \n    throw new Error(`Invalid image source: ${image}`);\n  }\n  \n  private static async loadRemoteImage(url: string): Promise<string> {\n    // Check if already loading\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url)!;\n    }\n    \n    // Check cache first\n    const cached = this.cache.get(url);\n    if (cached && (Date.now() - cached.timestamp) < this.CACHE_DURATION) {\n      return cached.objectUrl;\n    }\n    \n    // Create loading promise\n    const loadingPromise = this.fetchAndCacheImage(url);\n    this.loadingPromises.set(url, loadingPromise);\n    \n    try {\n      const result = await loadingPromise;\n      this.loadingPromises.delete(url);\n      return result;\n    } catch (error) {\n      this.loadingPromises.delete(url);\n      throw error;\n    }\n  }\n  \n  private static async fetchAndCacheImage(url: string): Promise<string> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        mode: 'cors',\n        cache: 'default',\n        headers: {\n          'Accept': 'image/*'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const contentType = response.headers.get('content-type') || '';\n      if (!ImageValidator.isValidImageFormat(contentType)) {\n        throw new Error(`Unsupported image format: ${contentType}`);\n      }\n      \n      const blob = await response.blob();\n      if (!ImageValidator.validateImageSize(blob)) {\n        throw new Error('Image file too large');\n      }\n      \n      // Clean up old cache entry if exists\n      const oldCached = this.cache.get(url);\n      if (oldCached) {\n        URL.revokeObjectURL(oldCached.objectUrl);\n      }\n      \n      // Create new cache entry\n      const objectUrl = URL.createObjectURL(blob);\n      const cached: CachedImage = {\n        url,\n        blob,\n        timestamp: Date.now(),\n        objectUrl\n      };\n      \n      this.cache.set(url, cached);\n      \n      // Clean up old cache entries periodically\n      this.cleanupCache();\n      \n      return objectUrl;\n    } catch (error) {\n      throw new Error(`Failed to load image from ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  private static cleanupCache(): void {\n    const now = Date.now();\n    for (const [url, cached] of this.cache.entries()) {\n      if (now - cached.timestamp > this.CACHE_DURATION) {\n        URL.revokeObjectURL(cached.objectUrl);\n        this.cache.delete(url);\n      }\n    }\n  }\n  \n  static clearCache(): void {\n    for (const cached of this.cache.values()) {\n      URL.revokeObjectURL(cached.objectUrl);\n    }\n    this.cache.clear();\n    this.loadingPromises.clear();\n  }\n}\n\nexport class TabsBarWeb extends WebPlugin implements TabsBarPlugin {\n  private loadingStates = new Map<string, ImageLoadingState>();\n  private imageLoadPromises = new Map<string, Promise<void>>();\n  \n  async configure(options: TabsBarConfigureOptions): Promise<void> {\n    // Validate color options if provided\n    if (options.selectedIconColor && !isValidColor(options.selectedIconColor)) {\n      console.warn(`TabsBar: Invalid selectedIconColor format: ${options.selectedIconColor}`);\n    }\n    if (options.unselectedIconColor && !isValidColor(options.unselectedIconColor)) {\n      console.warn(`TabsBar: Invalid unselectedIconColor format: ${options.unselectedIconColor}`);\n    }\n    \n    // Validate and preload images\n    await this.validateAndPreloadImages(options.items);\n    \n    // Web implementation logs configuration for debugging\n    console.log('TabsBar configured with options:', {\n      itemCount: options.items.length,\n      initialId: options.initialId,\n      visible: options.visible,\n      hasSelectedColor: !!options.selectedIconColor,\n      hasUnselectedColor: !!options.unselectedIconColor\n    });\n  }\n  \n  private async validateAndPreloadImages(items: TabItem[]): Promise<void> {\n    const imagePromises = items\n      .filter(item => item.imageIcon)\n      .map(item => this.preloadItemImage(item));\n    \n    await Promise.allSettled(imagePromises);\n  }\n  \n  private async preloadItemImage(item: TabItem): Promise<void> {\n    if (!item.imageIcon) return;\n    \n    const { id } = item;\n    const { imageIcon } = item;\n    \n    // Skip if already loading\n    if (this.imageLoadPromises.has(id)) {\n      return this.imageLoadPromises.get(id);\n    }\n    \n    this.loadingStates.set(id, 'loading');\n    \n    const loadPromise = this.loadImageIcon(imageIcon)\n      .then(() => {\n        this.loadingStates.set(id, 'loaded');\n        console.log(`TabsBar: Successfully loaded image for tab ${id}`);\n      })\n      .catch((error) => {\n        this.loadingStates.set(id, 'error');\n        console.warn(`TabsBar: Failed to load image for tab ${id}:`, error.message);\n        \n        // Fallback to system icon if available\n        if (item.systemIcon) {\n          console.log(`TabsBar: Using systemIcon fallback for tab ${id}: ${item.systemIcon}`);\n        } else {\n          console.warn(`TabsBar: No fallback available for tab ${id}`);\n        }\n      })\n      .finally(() => {\n        this.imageLoadPromises.delete(id);\n      });\n    \n    this.imageLoadPromises.set(id, loadPromise);\n    return loadPromise;\n  }\n  \n  private async loadImageIcon(imageIcon: ImageIcon): Promise<string> {\n    try {\n      return await ImageManager.loadImage(imageIcon);\n    } catch (error) {\n      throw new Error(`Image loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  /** Get the loading state of an image for a specific tab */\n  getImageLoadingState(tabId: string): ImageLoadingState | undefined {\n    return this.loadingStates.get(tabId);\n  }\n  \n  /** Clear all cached images */\n  clearImageCache(): void {\n    ImageManager.clearCache();\n    this.loadingStates.clear();\n    this.imageLoadPromises.clear();\n  }\n  \n  async show(): Promise<void> {\n    console.log('TabsBar: show() called');\n  }\n  \n  async hide(): Promise<void> {\n    console.log('TabsBar: hide() called');\n  }\n  \n  async select(options: SelectOptions): Promise<void> {\n    console.log('TabsBar: select() called with id:', options.id);\n  }\n  \n  async setBadge(options: SetBadgeOptions): Promise<void> {\n    console.log('TabsBar: setBadge() called with:', options);\n  }\n  \n  async getSafeAreaInsets(): Promise<SafeAreaInsets> {\n    return { top: 0, bottom: 0, left: 0, right: 0 };\n  }\n}","/**\n * Unified entry for all native overlay components.\n * Currently exports: TabsBar\n */\n\nexport { TabsBar } from \"./components/tabs\";\nexport type {\n  TabsBarPlugin,\n  TabsBarConfigureOptions,\n  TabItem,\n  SafeAreaInsets,\n  SetBadgeOptions,\n  SelectOptions,\n  BadgeValue\n} from \"./components/tabs/definitions\";","import { registerPlugin } from \"@capacitor/core\";\nimport type { TabsBarPlugin } from \"./definitions\";\n\nexport * from \"./definitions\";\n\n/** Named export for the TabsBar plugin within the larger library */\nexport const TabsBar = registerPlugin<TabsBarPlugin>(\"TabsBar\", {\n  web: () => import(\"./web\").then(m => new m.TabsBarWeb()),\n});"],"mappings":"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","names":["import_core"]}