{"version":3,"sources":["../src/components/tabs/web.ts","../src/components/tabs/color-utils.ts"],"sourcesContent":["import { WebPlugin } from \"@capacitor/core\";\nimport type {\n  TabsBarPlugin,\n  TabsBarConfigureOptions,\n  SelectOptions,\n  SetBadgeOptions,\n  SafeAreaInsets\n} from \"./definitions\";\nimport { isValidColor } from \"./color-utils\";\n\nexport class TabsBarWeb extends WebPlugin implements TabsBarPlugin {\n  async configure(options: TabsBarConfigureOptions): Promise<void> {\n    // Validate color options if provided\n    if (options.selectedIconColor && !isValidColor(options.selectedIconColor)) {\n      console.warn(`TabsBar: Invalid selectedIconColor format: ${options.selectedIconColor}`);\n    }\n    if (options.unselectedIconColor && !isValidColor(options.unselectedIconColor)) {\n      console.warn(`TabsBar: Invalid unselectedIconColor format: ${options.unselectedIconColor}`);\n    }\n    // Web implementation is no-op, but we validate for consistency\n  }\n  async show(): Promise<void> {}\n  async hide(): Promise<void> {}\n  async select(_: SelectOptions): Promise<void> {}\n  async setBadge(_: SetBadgeOptions): Promise<void> {}\n  async getSafeAreaInsets(): Promise<SafeAreaInsets> {\n    return { top: 0, bottom: 0, left: 0, right: 0 };\n  }\n}","/**\n * Color validation utilities for TabsBar configuration\n */\n\n/**\n * Validates if a string is a valid hex color code\n * @param color - The color string to validate\n * @returns true if valid hex color, false otherwise\n */\nexport function isValidHexColor(color: string): boolean {\n  const hexRegex = /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;\n  return hexRegex.test(color);\n}\n\n/**\n * Validates if a string is a valid RGBA color code\n * @param color - The color string to validate\n * @returns true if valid RGBA color, false otherwise\n */\nexport function isValidRgbaColor(color: string): boolean {\n  const rgbaRegex = /^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i;\n  \n  const match = color.match(rgbaRegex);\n  if (!match) return false;\n  \n  const [, r, g, b, a] = match;\n  const red = parseFloat(r);\n  const green = parseFloat(g);\n  const blue = parseFloat(b);\n  const alpha = a ? parseFloat(a) : 1;\n  \n  return (\n    red >= 0 && red <= 255 &&\n    green >= 0 && green <= 255 &&\n    blue >= 0 && blue <= 255 &&\n    alpha >= 0 && alpha <= 1\n  );\n}\n\n/**\n * Validates if a string is a valid color (hex or RGBA)\n * @param color - The color string to validate\n * @returns true if valid color format, false otherwise\n */\nexport function isValidColor(color: string): boolean {\n  if (!color || typeof color !== 'string') return false;\n  return isValidHexColor(color) || isValidRgbaColor(color);\n}\n\n/**\n * Converts hex color to RGBA format\n * @param hex - Hex color string (e.g., \"#FF5733\" or \"#F57\")\n * @param alpha - Optional alpha value (0-1), defaults to 1\n * @returns RGBA color string or null if invalid hex\n */\nexport function hexToRgba(hex: string, alpha: number = 1): string | null {\n  if (!isValidHexColor(hex)) return null;\n  \n  // Remove # if present\n  hex = hex.replace('#', '');\n  \n  // Handle 3-digit hex\n  if (hex.length === 3) {\n    hex = hex.split('').map(char => char + char).join('');\n  }\n  \n  // Handle 8-digit hex (with alpha)\n  if (hex.length === 8) {\n    const alphaHex = hex.slice(6, 8);\n    alpha = parseInt(alphaHex, 16) / 255;\n    hex = hex.slice(0, 6);\n  }\n  \n  const r = parseInt(hex.slice(0, 2), 16);\n  const g = parseInt(hex.slice(2, 4), 16);\n  const b = parseInt(hex.slice(4, 6), 16);\n  \n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\n/**\n * Normalizes a color string to a consistent format for native processing\n * @param color - Color string in hex or RGBA format\n * @returns Normalized color object with r, g, b, a values (0-1 range) or null if invalid\n */\nexport function normalizeColor(color: string): { r: number; g: number; b: number; a: number } | null {\n  if (!color || typeof color !== 'string') return null;\n  \n  if (isValidHexColor(color)) {\n    const rgba = hexToRgba(color);\n    if (!rgba) return null;\n    color = rgba;\n  }\n  \n  if (isValidRgbaColor(color)) {\n    const match = color.match(/^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i);\n    if (!match) return null;\n    \n    const [, r, g, b, a] = match;\n    return {\n      r: parseFloat(r) / 255,\n      g: parseFloat(g) / 255,\n      b: parseFloat(b) / 255,\n      a: a ? parseFloat(a) : 1\n    };\n  }\n  \n  return null;\n}"],"mappings":";AAAA,SAAS,iBAAiB;;;ACSnB,SAAS,gBAAgB,OAAwB;AACtD,QAAM,WAAW;AACjB,SAAO,SAAS,KAAK,KAAK;AAC5B;AAOO,SAAS,iBAAiB,OAAwB;AACvD,QAAM,YAAY;AAElB,QAAM,QAAQ,MAAM,MAAM,SAAS;AACnC,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,IAAI;AACvB,QAAM,MAAM,WAAW,CAAC;AACxB,QAAM,QAAQ,WAAW,CAAC;AAC1B,QAAM,OAAO,WAAW,CAAC;AACzB,QAAM,QAAQ,IAAI,WAAW,CAAC,IAAI;AAElC,SACE,OAAO,KAAK,OAAO,OACnB,SAAS,KAAK,SAAS,OACvB,QAAQ,KAAK,QAAQ,OACrB,SAAS,KAAK,SAAS;AAE3B;AAOO,SAAS,aAAa,OAAwB;AACnD,MAAI,CAAC,SAAS,OAAO,UAAU,SAAU,QAAO;AAChD,SAAO,gBAAgB,KAAK,KAAK,iBAAiB,KAAK;AACzD;;;ADrCO,IAAM,aAAN,cAAyB,UAAmC;AAAA,EACjE,MAAM,UAAU,SAAiD;AAE/D,QAAI,QAAQ,qBAAqB,CAAC,aAAa,QAAQ,iBAAiB,GAAG;AACzE,cAAQ,KAAK,8CAA8C,QAAQ,iBAAiB,EAAE;AAAA,IACxF;AACA,QAAI,QAAQ,uBAAuB,CAAC,aAAa,QAAQ,mBAAmB,GAAG;AAC7E,cAAQ,KAAK,gDAAgD,QAAQ,mBAAmB,EAAE;AAAA,IAC5F;AAAA,EAEF;AAAA,EACA,MAAM,OAAsB;AAAA,EAAC;AAAA,EAC7B,MAAM,OAAsB;AAAA,EAAC;AAAA,EAC7B,MAAM,OAAO,GAAiC;AAAA,EAAC;AAAA,EAC/C,MAAM,SAAS,GAAmC;AAAA,EAAC;AAAA,EACnD,MAAM,oBAA6C;AACjD,WAAO,EAAE,KAAK,GAAG,QAAQ,GAAG,MAAM,GAAG,OAAO,EAAE;AAAA,EAChD;AACF;","names":[]}